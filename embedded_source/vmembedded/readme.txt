                       Lattice Semiconductor Corp.
                 IEEE 1532 Compliance ispVM(tm) Embedded
                             Release Notes

ispVM Embedded v12.1	    Date:4/01/09
====================================
ISPVME
1.  UPDATE- Replaced the recursive function call codes on the ispVMLCOUNT function. This ensures that the codes will be  
            supported for all the compilers. 
            

ispVM Embedded v12.1	    Date:9/11/08
====================================
ISPVME
1.  UPDATE- Added Calculate checksum support which print out the 16 bit checksum to the terminal.
            The checksum will be calculated when process the "Calculate Checksum" operation VME file generated by ispVM. 

SVF2VME
1.  UPDATE- Added new option under -max_size flag. Specifies the maximum value allowed to allocate memory
            for a row of data in KBytes. Ex. 8,16,32,64, 128, 256
            Default: 64 KBytes.

ispVM Embedded v12.1	    Date:9/11/07
====================================
ISPVME
1.  UPDATE- Add DRPAUSE-DRPAUSE path to the JTAG state machine transition trajectory table to support XP and XO Devices
            Clean up the code and type cast all the mismatch variables 

SVF2VME
1.  UPDATE- Add DRPAUSE-DRPAUSE path to the JTAG state machine transition trajectory table to support XP and XO Devices
            Clean up the code and type cast all the mismatch variables 

ispVM Embedded v12.1	    Date:3/14/06
====================================

ISPVME
1.  FEATURE- Lattice-specific SVF files with the ISPEN command are supported. This new command ensures that
    the IspENABLE signal is driven based on ON/OFF values.
2.  UPDATE- Add DRCAPTURE to the JTAG state machine transition trajectory table to support XP and XO Devices

SVF2VME
1.  FEATURE- Lattice-specific SVF files with the ISPEN command are supported. This new command ensures that
    the IspENABLE signal is driven based on ON/OFF values.

2.  UPDATE- Add DRCAPTURE to the JTAG state machine transition trajectory table to support XP and XO Devices


ispVM Embedded v12.0	    Date:6/03/05
====================================

ISPVME
1.  FEATURE- Lattice-specific SVF files with the LVDS command are supported. This new command ensures that
    the LVDS pairs are driven opposite values.
2.  UPDATE- If the pre-processor directive VME_DEBUG is defined during compilation, the embedded processor
    will display debugging messages that should match the original SVF file along with the device TDO data.

SVF2VME
1.  FEATURE- Lattice-specific SVF files with the LVDS command are supported. This new command ensures that
    the LVDS pairs are driven opposite values.
2.  BUG FIX- Per the SVF standard, SIR and SDR MASKs should be retained if the data length does not change
    and a new MASK is not present.
3.  The LOOP support has been removed when converting SVF to VME.

ispVM Embedded v11.1	Date:4/14/05
====================================

SVF2VME
1.  FEATURE- The command line switch "-max_tck" shall allow the user to specify the maximum number of TCK clocks
    when converting the SVF to VME. This number shall be the maximum number of TCK clocks that a RUNTEST command
    can execute. Additionally, the TCK clocks shall also be converted to delay time based on the specified
    frequency. For example, if the maximum TCK was set at 1000 with a frequency of 1 MHz, then the following command:
    
        RUNTEST 1000000 TCK;
        
    would be converted to:
    
        RUNTEST 1000 TCK;
        RUNTEST 1.00E-000 SEC;
        
    The switch "-max_tck" is applied to each individual SVF file. If the switch is not provided, then the default 
    maximum TCK is 1000. If the SVF file does not have a frequency statement, then the number of TCK clocks shall
    be honored exactly as they appear in the SVF since it will be impossible to convert them to delay time.
    
    This feature may be necessary when supporting non-Lattice devices or SVF files that contain large TCK clocks.
    Converting large TCK clocks to delay time insures that the device observes adequate delay.

2.  UDPDATE- Any TCK clocks that are less than the max_tck value shall be honored. Additionally, they shall also
    be converted to delay time based on the specified frequency.

3.  BUG FIX- The frequency statement in the SVF file shall be honored when the command line switch "-clock" is not
    used. Previously, the frequency statement was ignored and defaulted to 1 MHz if "-clock" was not used.
    
4.  BUG FIX- HDR and HIR were calculated incorrectly when chaining multiple SVFs into a single VME.

5.  BUG FIX- If RUNTEST command does not contain a safe state, then default the safe state to IDLE.

ispVM Embedded v11.0.1	Date:11/10/04
====================================
ISPVME
1.  BUG FIX- If the VME CRC has been modified to be 0x0000, then do not compare it against the calculated CRC.

SVF2VME
1.  BUG FIX- Return an error if SVF comments are preceded only with / (single forward slash).

ispVM Embedded v11.0	Date:9/22/04
====================================
ISPVME
1.  FEATURE- VME files that support comments shall have them displayed onto the terminal during processing.  This
    feature serves two purposes:
    1) It can be used as a debugging tool to locate the position where the VME fails based on the displayed
       comments.
    2) It can be used to inform the user which portion of the VME file is currently being processed.
2.  FEATURE- VME files that are CRC protected shall be calculated to match the expected CRC.  If the comparison
    fails, the program returns with a CRC error code.
3.  FEATURE- VME files that program PROM and FLASH devices using intelligent programming shall be supported.
4.  FEATURE- VME files that are generated with display operations shall display those values onto the terminal.
5.  UPDATE- In the function ispVMDelay of the file hardware.c, the incoming delay shall be logically AND-ed with 
    0xA000 instead of 0x8000.  This is done because ispSVF v2.0.1 encodes the delay time with 0x2000, while ispSVF
    v2.1 and higher encodes it with 0x8000.  This encoding is done to indicate that the delay is in milliseconds.
    If the respective bit is not encoded, the delay is in microseconds.  By using 0xA000, it will make VME processor
    compatible with both versions of VME files.
6.  BUG FIX- Functions that return negative values shall have a return type of 'signed char'.  Previously,
    these functions only used 'char' as the return type.  Since the signed property of 'char' is machine
    dependent, the code has been changed to make the signed explicit.

SVF2VME
1.  FEATURE- The command line switch "-comment" shall generate VME files with comments.  When ispVM Embedded processes
    the VME file, the comments shall be displayed to the terminal.  Comments are any text that begins with "!" or "//"
    until the end of the line.
2.  FEATURE- VME file will be generated with a 16-bit CRC to protect the integrity of the file.  The ispVM Embedded 
    will calculate and compare the CRC prior to processing the file.
3.  FEATURE- SVF files that program PROM and FLASH devices using intelligent programming shall be supported.  These
    files contain the following keywords: LCOUNT, LDELAY, and LSDR.
4.  UPDATE- RUNTEST commands in the SVF file shall be converted to VME exactly as specified by the SVF.  Previously,
    large TCKs were truncated to only 3 TCKS, and converted to delay time.
5.  UPDATE- Reinstate IEEE 1532 support.
6.  UPDATE- The version of the SVF2VME utility has been updated to match with the ispVM Embedded.
7.  UPDATE- The verify UES feature will only be available when generating the VME file through ispVM System.  The command
    line argument "-verify_ues" will no longer be recognized by SVF2VME.

ispVM Embedded v10.1.1	Date:1/19/04
===================================
ISPVME
1.  Update- Convert integers to short to resolve system dependency.
2.  Update- Remove IEEE 1532 support.
3.  Update- Remove VME_NT precompiler switch from released source code.

SVF2VME
1.  Update- Remove IEEE 1532 support.
2.  Update- Default to no looping.  The command line argument to enable looping is -loop, or -l, for short.

ispVM Embedded v10.1	Date:1/19/04
===================================
ISPVME
1.  Bug Fix- If multiple VME files are given as command line arguments and an error occurs, then
return the error immediately instead of waiting for all the VME files to process.

ispVM Embedded v10.1	Date:1/19/04
===================================
SVF2VME
1.  Update- If the TCK count in the RUNTEST command of the SVF file is greater than 1000, three TCK
toggles will be executed and the TCK count will be converted to delay.

ispVM Embedded v10.1	Date:1/16/04
===================================
SVF2VME
1.  Bug Fix- Fix VME processor to use integer instead of unsigned integer to observe large TCK clocks.

ispVM Embedded v10.1	Date:1/15/04
===================================
SVF2VME
1.  Bug Fix- When performing cascading, the non-residual cascaded frames will shift in the last bit.
The residual cascaded frame will not, however, shift in the last bit.  This is consistent with
processing regular data, where the last bit is not shifted into the device.

ispVM Embedded v10.1	Date:1/09/04
===================================
SVF2VME
1.  Bug Fix- Remove the partially generated VME file if a failure occurred during generation.

ispVM Embedded v10.1	Date:1/06/04
===================================
SVF2VME
1.  Bug Fix- If cascading is being performed, the device will be shifted to PAUSEDR prior to
and after shifting in all of the cascaded frames.  This is necessary to put the device in safe
states.  Without this, undefined transitions were discovered.

ispVM Embedded v10.1	Date:6/04/03
===================================
Another addition to ispVM Embedded v10.1 is the support of dynamic I/O capture.  All the modules
have been updated to support dynamic I/O opcodes.  To activate this feature, the SVF provided 
must have DMASK.

ispVM Embedded v10.1	Date:4/28/03
===================================
The major enhancements to v10.1 are the support of Continue If Fail (USERCODE verification)
and updates to the command line usage of the SVF2VME utility.  Minor enhancements were made to
redefine the preprocessor switches.  Below are detailed descriptions of the changes:

1.  Continue If Fail (USERCODE Verification)
The Continue If Fail is a feature that allows the USERCODE of the device to be verified prior to 
programming.  If the USERCODE of the device matches the USERCODE in the VME file, then programming is
aborted with an appropriate message to indicate that the device already contains the pattern in the
VME file.  If the USERCODE fails to match, then programming is initiated.  Note that the implication
here is that the user must assign a distinct USERCODE to each distinct pattern.

This feature is beneficial to ispVM Embedded users because it eliminitates redundant programming of 
the same pattern into the device.  This can be a handy feature in a resource-limited embedded system
platform because it saves precious micro-controller cycles, calls to peripherals, and memory read and writes
by aborting the programming process without having to program and/or verify the same pattern in the device.

This feature can be invoked in the SVF2VME utility by supplying the argument "-verify_ues", or "-vues" for
short (see SVF2VME Command Line Usage below).  The SVF file(s) that is supplied along with this argument must
satisfiy the following conditions:
	1)  It must be generated with the operation Erase, Program, Verify
	2)  If the SVF file is a sequential file, it must be generated without the option "Synchronize 
	    Enable and Disable Procedure" from the Project Settings in ispVM System.
	3)  The generated SVF comments must not be modified or removed.  In particular, the ID code
            and USERCODE verification comments must not be changed or deleted.

2.  SVF2VME Command Line Usage
The current SVF2VME command line usage has been updated to support Continue If Fail,  maintain consistency
with other ispVM Modules, and ameliorate future command line support.

The new usage is:
	svf2vme	[ -help |
		[ -full ]
		[ -no_loop ]
		  -infile  < input file path1 > [ -clock < frequency > ] [ -vendor < altera |
                                                                                     xilinx > ] [ -verify_ues ]
		[ -infile  < input file path2 > [ -clock < frequency > ] [ -vendor < altera | 
                                                                                     xilinx > ] [ -verify_ues ] ]
		[ -bypass  < instruction register length > ]
		[ -outfile < output file path > ]
                ]

	Description:
	-help:				Display the help information.  Optional.
	-h:				Shorthand for -help.  Optional.
	-full:				Generate the VME file without compression.  Optional.
					Default: generate with compression.
	-f:				Shorthand for -help.
	-verify_ues:			Verify USERCODE before programming.  Optional.
	-vues:				Shorthand for -verify_ues.
	-no_loop:			Generate the VME file without looping.  Optional.
					Default: looping VME file is generated.
	-nl:				Shorthand for -no_loop.
	-infile < input file path >:	SVF file path.
	-if < input file path >:	Shorthand for -infile.
	-clock < frequency >:		Specify the frequency.  Optional.  Default: the default
					frequency is 1MHz.
	-c < frequency >:		Shorthand for -clock.
	-vendor < altera | xilinx >:		Specify vendor.  Optional.  Default: the default
						vendor is Lattice.
	-v < altera | xilinx >:		Shorthand for -vendor.
	-bypass < instruction register length >:	Specify the IR length of the device to 
							bypass.  Optional.
	-by < instruction register length >:		Shorthand for -bypass.
	-outfile < output file path >:	VME file path.  Optional.  Default: uses the
						input file path name.
	-of < output file path >:		Shorthand for -outfile.

The following command line example will generate a slim, looping VME with the Continue If Fail option.
The output file name will be C:\output.vme

	C:\svf2vme -infile C:\file1.svf -verify_ues -outfile C:\output.vme

The following command line example will generate a slim, looping VME using the default output file name, 
with the frequency set to 100KHz:

	C:\svf2vme -infile C:\file1.svf -clock 100K // Generated VME is C:\file1.vme

The following command line example will generate a full, looping VME using the default output file name, 
with the frequency of the first file set to 100KHz, and the frequency of the second file set to 10MHz:

	C:\svf2vme -infile C:\file1.svf -clock 100K -infile C:\file2.svf -clock 10M -full

3.  Preprocessor Switch Redefinitions
The preprocessor switches have been redefined in the ispVME and ispVME EPROM modules to make them 
unique to ispVM Embedded, and to allow easy enabling and disabling of features prior to compiling.  These 
switches are "VME_1532", "VME_DEBUG", and "VME_NT".  By defining these preprocessor definitions in the 
makefile before compiling, it will enable their respective functions.

	VME_1532:  This definition will compile IEEE 1532 compliant ispVM Embedded and ispVM Embedded EPROM
		   modules.  If this is not defined, it will compile non-IEEE 1532 compliant modules (i.e. 
		   IEEE 1532 support will have been stripped off).
	VME_DEBUG: This definition will compile debug versions of ispVM Embedded and ispVM Embedded EPROM.
		   The header file Debug.h must be in the project before compilation.
	VME_NT:    This definition will compile NT-ready ispVM Embedded and ispVM Embedded EPROM modules.
		   This build requires proprietary header and implementation files that Lattice does not 
		   release.  Only internal engineers may obtain these files.  If this is not defined, it
		   will compile Windows 95/98-ready ispVM Embeddded and ispVM Embbedd EPROM modules.

ispVM Embedded v10.0	Date:4/7/03
===================================
SVF2VME
1.  In STATECom function, if a long state is given, return failure.
2.  Change the variables MaxSize and scan_len to unsigned long for easier porting to 16-bit.
3.  Change version number to VME 2.0.1. Note: the internal version number will still be 2.0
    in order for the decoder to accept files generated with this version.

ispVM Embedded V10.0	Date:10/22/02
=====================================
SVF2VME
1.  Bug Fix- Fix data compression to ispStream
ISPVME
2.  Bug Fix- Free memory for each VME file before processing the next file
    if multiple VME files are given.
3.  Bug Fix- Set pointers to NULL after deallocating memory.

ispVM Embedded V10.0	Date:9/30/02
====================================
Update
1.  The SVF2VME utility can take in any vendor name.  If the vendor name
    is not Altera or Xilinx, then it defaults to the standard.

ispVM Embedded V10.0	Date:4/16/02
=========================================================================
The major enhancement made on V10.0 is the addition of tokens to
support CRC calculation mandated by the newly adopted IEEE 1532 standard.
This is to illustrate the highly scalable nature of the ispVM design.
Read and save an IEEE 1532 defined files from the device is also added
to further illustrate the unlimited capability of ispVM. 

When new tokens are added to support new features, the footprint of
ispVM is also increased proportionately. Additional run-time resources 
may be required by the function associate with the token. 
Example: Quite a large amount of resources is needed to support the
         CRC calculation and the read and save required by IEEE 1532.

If user want to reduce the foot-print and resources needed such as when
porting the ispVME to 8051 micro-controller, any functions associate with 
the CRC calculation and read and save can be deleted from the ispVME source 
completely. Please contact Lattice Application for the detail. 

The procedure to use the IEEE 1532 features:
1. Obtain an ISC data file (the IEEE 1532 equivalent of JEDEC file).
2. Obtain the ISC BSDL file (a standard BSDL file with IEEE 1532 
   programming flow included) for the device of the ISC data file.
3. Generate the SVF file by using the ISC Compiler in ispVM System V10.0
   and higher. Select the extended SVF format.
4. Use SVF2VME10.exe to convert the SVF file into VME file. 
5. Use ispVME V10 to execute the VME file. 

NOTES:
The VME file generated by svf2vme V10 is for ispVME 10.0 only.
Similarly the VME file generated by svf2vme V9 is for ispVME 9.0 only.
The VME file generated by svf2vme V8 is for ispVME 8.1 and 8.0 only.

V10.0	Date:7/25/02
-------------------------
VME2HEX
1.  Bug fix - Fixed the problem for incorrect header files generated from a chain VME file.  

V10.0	Date:7/25/02
-------------------------
SVF2VME
1.  Bug fix - When a chain of SVF files are being generated into one VME file, if one of
    the SVF files fails to loop, then revert all looping SVF files back to 
    regular SVF files.


V10.0 Additions and/or changes:
-------------------------
SVF2VME
1.  The SVF2VME converter will attempt to compress the SVF file into a looping
    SVF file and then convert it to VME.  This conversion will decrease the VME 
    file size.  If a looping SVF cannot be constructed, it automatically resumes
    a flat SVF.  The default is set to looping SVF.  However, the converter has 
    an option to disable the looping.  This option is "-nl" at the command line.

    Example:  svf2vme myfile.svf -nl -o C:\output.vme

2.  The SVF2VME converter has an option to specify the vendor.  The default vendor is 
    lattice.  However, if using a competitor part, the command line option "-v" must
    follow the competitor SVF name.  The name of the competitor must follow the option 
    "-v" in the command line.

    Example:  svf2vme xilinx.svf -v xilinx
    Example:  svf2vme altera.svf -v altera -o C:\output.vme

    The v option is necessary for:
    Xilinx's devices need some repetitive looping to check the status bit to ensure 
    device enter programming mode. 
    Altera's devices need longer erase time and programming time than what is specified 
    on the SVF file. 

3.  Supports SVF files with CRC, CMASK, READ, and RMASK.

ISPVME
1.  The major change in the VME processor is that it is IEEE 1532 compilant.  The VME
    processor calculates the data CRC if the SVF used to generate the VME has CRC and 
    CMASK key words.  If the SVF is a daisy chain, it calculates one data CRC per device.
    
    Data CRC SVF Example:
    ---------------------
    SDR     80
        TDI     (00000000000000000000)
        TDO     (FFFFBFFFFFFFFFFFFFFF)
        CRC     (FFFFFFFFFFFFFFFFFFFF)
        CMASK   (FFFFFFFFFFFFFFFFFFFF);


    The VME performs Read and Save if the SVF used to generate the VME has
    READ and RMASK key words.  

    Read and Save SVF Example:
    --------------------------
    SDR     80
        TDI     (00000000000000000000)
        CRC     (FFFFFFFFFFFFFFFFFFFF)
        CMASK   (FFFFFFFFFFFFFFFFFFFF)
        READ    (FFFFFFFFFFFFFFFFFFFF)
        RMASK   (FFFFFFFFFFFFFFFFFFFF);

    The VME will read and save from the device into an ISC Data file.  This ISC 
    Data file will be an unprocessable data file because the VME does not know the
    entity name and the different programming sections of the device such as Usercode, 
    SysIO, and etc.  The resulting ISC Data file will be denoted with the data tag:

    data unprocessed_array.

    ISC Data file generated from VME V10.0 Example:
    -----------------------------------------------
    IEEE_1532_Data
    (
      header
      (     std_version STD_1532_2001
            creation_date 20020307.1338
      )
      data unprocessed_array
        (   repeat
            (
                  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                  00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000174D6157,
                  3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
                  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                  0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                  FFFFFFFF
            )
        )
    )

    The VME processor will save the ISC Data file into the same directory as the VME 
    file.  It will use the name of the VME file as the name of the ISC Data file.  

EPROM ISPVME
1.  The EPROM version of ISPVME performs calculate data CRC as mentioned above.  However,
    it does not perform Read and Save because the EPROM version is likely to be used on
    embedded controllers and processors. 

ispVM Embedded V9.1   Date:11/30/01
=========================================================================

Additions and/or changes:
-------------------------
1.  Supports competitors' parts.
2.  VME executable contains the option to increase the delay time 
    by percentage (on both EPROM and non-EPROM based VMEs).
3.  Wakes up demoboards from programming mode.
4.  Fixed encoding bug when compressing data by 0xFF or 0x00 (found
    when programming Vantis demo board with turbo SVF).
5.  Stretch the clock for 3K devices.

ispVM Embedded V9.0   Date:10/29/01
=========================================================================

UPDATE:
------------

Version V8.0 supports only a single device in a SVF file. A single device
SVF file always have zero headers. Example:
         HIR 0;
Such restriction is imposed by rejecting a SVF file with a non-zero
HIR,TIR,HDR and TDR when launching SVF2VME utility to convert SVF files
into VME files.

Version 9.0 accepts the non-zero constructs of HIR,TIR,HDR and TDR.
Example: HIR 32 TDI (00000000);
However more complex constructs are not supported. Example:
         HIR 32 TDI (00000000) TDO (00000000);
         HIR 32 TDI (00000000) TDO (00000000) MASK (FFFFFFFF);

When the SVF file is known to be for multiple devices, only one
SVF file can be converted in a time by the SVF2VME utility. 

SVF2VME has the capability to chain up multiple single device SVF
files. Example:
       svf2vme dev1.svf dev2.svf ...
If the SVF file is already for a chain of devices, further chaining
could not be done and should not be done by svf2vme.

If the chain is a multiple vendor chain, then ispvme.exe should be
used to process the multiple vme files. Example:
The Chain:   Device    Name             Files       Operation
             1         iMACH4A3-128/64  mach1.jed   erase,program,verify
             2         A-PLD            a1.svf      process
             3         ispLSI2128VE     isplsi1.jed erase,program,verify
             4         Moto-uP          8           Bypass

Step 1:
ispVM System V9.0.2 or newer can be used to convert the mach1.jed and
isplsi1.jed into a single SVF file for the entire chain with turbo
programming selected. This SVF file will erase program and verify
device 1 and 3 concurrently while bypassing device 2 and 3. 

Step 2:
Convert the turbo programming SVF file into a VME file by typing
          svf2vme turbo.svf
The file turbo.vme will be created as a result.

Step 3:
Convert the single device SVF file for device 2 into a multiple
device VME file by typing
          svf2vme 6 a1.svf 5 8
The file a1.vme will be created as a result.
Note: The numerical value given as a parameter for svf2vme
      are the instruction length of device 1, 3 and 4 respectively.

Step 4:
Use ispVME to process the vme file(s) by typing
          ispvme turbo.vme a1.vme
ispVME will process turbo.vme file first then a1.vme file.
When turbo.vme file is being processed, device 1 and 3 are being
programmed and verified with the others in a bypass mode or
more realistically speaking, in an operation mode.
When a1.vme is being processed, only device 2 is being programmed
and the other devices are in operation mode.

The 3 modules which are compiled to be ispVME are all updated to
support multiple device VME files:
 ispvm_ui.c
 ivm_core.c
 hardware.c

ivm_core.c and hardware.c are included in ispvm_ui.c. Compiling
ispVME simply by:
 bcc -eispvme9.exe ispvm_ui.c


B. EPROM Based:

vme2hex.c is updated to support the conversion of multiple device
VME file into one or several HEX file(s).

ivm_ui8a.c is changed to ivm_ui9a.c to support multiple device
VME file.
ivm_hw8a.c is no longer needed so that hardware.c can also be
used. The 3 modules which are compiled into ispVME are:
 ivm_ui9a.c
 ivm_core.c
 hardware.c
ivm_core.c and hardware.c are included into ivm_ui9a.c to simplify
the compiling work.
Example: If VME2HEX created two vme hex files vme1.c and vme2.c,
         then compiling on BORLAND simply is:
   bcc -eturbo9.exe -mh ivm_ui9a.c vme1.c vme2.c

ispVM Embedded V8.0
=========================================================================

INTRODUCTION:
-------------
Lattice's ispCODE(tm) has been the industry standard in supporting 
Embedded In-System Programming. ispCODE has the smallest footprint, 
file size and resources requirement in the industry. This advantage 
is achieved by having the programming algorithm of ispLSI devices 
hard coded into the ispCODE core. As a consequence, ispCODE core 
will have to be updated when new devices with a different programming 
algorithm are to be supported. Simply stated, the data file for 
ispCODE, ispSTREAM(tm) file, contains only programming data, not 
algorithm.

Lattice will continue to support ispCODE for Lattice's devices only.

Lattice introduced ispVM(tm) for Multiple Vendor In-System 
Programming support on PC platform.

Lattice now introduces ispVM(tm) Embedded for Multiple Vendors 
In-System Programming support on Embedded applications.

The major difference between ispVM(tm) and ispCODE(tm) is that the 
file processed by ispVM(tm) Embedded, the Virtual Machine Embedded 
(VME) file contains both programming algorithm and data whereas 
ispSTREAM file for ispCODE contains only data.


The ispSTREAM file and VME file both are in binary form, thus they 
are ready to run on the native code and therefore leading to highest 
possible programming time and efficiency. 

ispVM(tm) comprises with:
1. IO:
   The user interface or data interface.
2. CORE:
   It is a rich set of high level and low level opcodes that perform 
   all the task of VME file decoding and data manipulation.
3. DRIVER:
   Convert the command and data from logical signals into electrical 
   signals to program devices.

The major advantages of ispVM(tm) Embedded:
1. Developed once, support all present and future In-System Programming
   devices. i.e. The same ispVM(tm) can be used forever without 
   modifications.
2. Hardware and platform independent. i.e. A VME file runs on all 
   ispVM(tm)Embedded.

The industry standard SVF (Serial Vector Format) file for BSCAN testing
and ispJTAG programming is the best file for ispVM(tm) Embedded due to 
the deterministic nature of the file: i.e. The programming algorithm, 
the programming data, the programming pulse width, and the resources 
(RAM and EPROM) required can be determined by parsing through the file.

It is not possible to develop an embedded application without knowing
the exact worst case amount of resources (RAM and EPROM) required.

SVF files are ASCII files and therefore an utility program SVF2VME is
provided to convert those files into binary VME files for ispVM(tm) 
Embedded.

As a result, only a small subset of the ispVM opcodes is required to 
be included in this ispVM(tm) Embedded to make this product the 
simplest and the lowest cost solution for Multiple Vendor Embedded 
In-System Programming.

FILES:
------
1. ispVM Embedded I/O (File Based)
   -ispvm_ui.c      The user interface for VME files residing on disk.
   -ispvme8.exe     The executable compiled as a 16 bits DOS 
			  application.
2. ispVM Embedded I/O (EPROM Based)
   -ispvmeui.c      The user interface for VME files residing in EPROM.
3. ispVM Embedded CORE
   -ivm_core.c      The CORE of ispVM Embedded.
   -vmopcode.h      The header file for ivm_core.c
4. ispVM Embedded DRIVER
   -hardware.c      The PC parallel port and Lattice Cable driver.
   -hardware.h      The header file for hardware.c
5. VME2HEX PROGRAM
   -vme2hex.c       The utility converts the binary VME file into 
			  HEX files.
   -hex_core.c      The VME file parser of VME2HEX program.
   -vmopcode.h      The header file for hex_core.c
   -vme2hex.exe     The executable compiled as a 32 bits DOS 
			  application.
6. SVF2VME PROGRAM
   -svf2vme.exe     The utility program chain and converts SVF files 
			  from Lattice and other PLD vendors into a single 
			  VME file for the entire chain.
   -svf2vme.c       The C source of svf2vme.exe.
                    Note: This file is not included in this package. 
				  Please contact Lattice Applications for a 
                          controlled copy.
UESAGE:
-------
A. ispVM Embedded (File Based)
1. Collect single device SVF files using the SVF files writers from 
   PLD vendors. 
2. Use the utility program SVF2VME to chain and convert the single 
   device SVF files into a single VME file for the entire chain. 
   Example:
   svf2vme chip1.svf -100K chip2.svf 10 chip4.svf -c 10M -o board1.vme
   Notes: -The 10 in the chip 3 position means that the IR length of 
	     the 3rd device is 10 and there is no SVF file for that 
           device. It will be bypassed the ispVM Embedded.
          -The chain order is that chip1 is where TDI goes into 1st.
          -The output filename if not supplied by -o flag, the name of
           the first SVF file encounter will used instead.
          -The TCK rate is defaulted to be 1MHZ. The -c flag follows 
           the SVF file name is to change the default to as specified.
3. Run the ispVM Embedded on PC with Lattice ispDownload Cable by 
   typing:
   vme board1.vme
4. Modify hardware.c and hardware.h to suit your targeted hardware 
   platform instead of using PC parallel port and Lattice's 
   ispDownload Cable. The 3 modules required for compiling the ispVM 
   Embedded:
      -ispvm_ui.c
      -ivm_core.c
      -hardware.c
   Note:  -Compile the program as a 16 bits application to get the 
           smallest footprint possible. The entire ispVM Embedded use 
           16 bits integer maximum except the ispVMDelay() function. 
           However the function most likely will be replaced entirely 
           by the users since as it is written, it works only on PC.
   
B: ispVM Embedded (EPROM Based)
1. Collect single device SVF files using the SVF files writers from 
   PLD vendors. 
2. Use the utility program SVF2VME to chain and convert the single 
   device SVF files into a single VME file for the entire chain. 
   Example:
   svf2vme chip1.svf -100K chip2.svf 10 chip4.svf -c 10M -o board1.vme
   Notes: -The 10 in the chip 3 position means that the IR length of 
           the 3rd device is 10 and there is no SVF file for that 
           device. It will be bypassed the ispVM Embedded.
          -The chain order is that chip1 is where TDI goes into 1st.
          -The output filename if not supplied by -o flag, the name 
           of the first SVF file encounter will be used instead.
          -The TCK rate is defaulted to be 1MHZ. The -c flag follows 
           the SVF file name is to change the default to as specified.
3. Use the utility program VME2HEX to convert the VME file into a HEX 
   file.
   Example:
      vme2hex board1.vme
   A vme_file.h file and at least 1 vme1.c file will be created.
   The vme_file.h is included into the module ispvmeui.c. 
   Notes: -Depends on the size of the VME file, more than one HEX file 
           might be created by vme2hex utility. Each HEX file size is 
           60000 bytes maximum. It is limited by the array size a 16 
           bits application can support.
          -The HEX file name has a .c extension. It is necessary due to
           each .obj is limited to 64000 bytes in size by the 16 bits 
           compilers.
4. Compile the program and test it on PC using Lattice's ispDownload 
   Cable.
   The 3 basic modules required to compile the program are:
      -ispvmeui.c     The EPROM I/O interface.
      -ivm_core.c     The CORE of ispVM Embedded.
      -hardware.c     The driver code.
   Example: 
   The vme2hex utility created two HEX files vme1.c and vme2.c.
   If using Borland C compiler, type
   bcc -mh -evme.exe ispvmeui.c ivm_core.c hardware.c vme1.c vme2.c
   Run the compiled program on PC simply type:
       vme
5. Modify hardware.c and hardware.h to suit your targeted hardware 
   platform instead of using PC parallel port and Lattice's ispDownload
   Cable. Compile and run the executable created.
   Note:  -Compile the program as a 16 bits application to get the 
           smallest footprint possible. The entire ispVM Embedded use 
           16 bits integer maximum except the ispVMDelay() function. 
           However the function most likely will be replaced entirely by 
           the users since as it is written, it works only on PC.

   
